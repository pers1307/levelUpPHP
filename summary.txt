1. Ссылки на элементы массивов
2. Проверка типов входящих данных
3. Наследование, повторное использование кода (parent)
4. static создание себе подобного объекта
5. Использовать исключения, а не коды ошибок.
6. Последний catch с дефолтным Exeption не должен никогда вызываться! (В идеале)
7. Удобно передавать исключение вверх бросая throw в catch.
8. Все объекты передаются по ссылке.
9. Можно добавлять функционал в методы при помощи функций обратного вызова.
10. Классам подключенным через use можно давать алиасы (use pers1307\blog\Ret as bRet)
11. __autoload для подключения классов, которые будут использоваться в коде.
12. class_exists
13. Reflection API для анализа экземпляров класса. (стр 114)
14. Обязанность каждого класса должна быть единичной.
15. Для документации удобно использовать phpDocumentor (http://www.phpdoc.org/) composer require phpdocumentor/phpdocumentor
    установка через Composer. Прописать в командной строке
    (vendor\bin\phpdoc -d ./ForDoc/ -t ./docs)
16. Для загрузки PHPUnit composer require "phpunit/phpunit=4.8.*"
17. Для запуска тестирования использовать команду: php phpunit.phar CalculatorTest.php
18. Но лучше, поместить все тесты к отдельный каталог и запустить их разом используя
    команду: php phpunit.phar test/
19. Все комменческие приложения делятся на уровни:
    Ур. представления данных (уровень пользователя)
    Ур. команд и управления (обработка запроса пользователя)
    Ур. логики приложения (обработка бизнес запроса)
    Ур. данных (механизм хранения и получения информации)
20. Магический метод __sleep() вызывается, когда объект сериализуется.
21. Магический метод __wakeup() вызывается, когда объект десериализуется.
22. Паттерн Front - Controller, очень важно внедрить его! стр. 275
23. Для установки CodeSniffer composer require squizlabs/php_codesniffer
24. Для запуска CodeSniffer vendor\bin\phpcs Visitor.php и выдаст все необходимы для исправления ошибки.
25. https://github.com/squizlabs/PHP_CodeSniffer/wiki справка к Code Sniffer.
26.1 Включение - когда один класс является атрибутом другого класса.
26.2  Предпочитайте композицию наследованию. (Композиция это включение в класс других классов в качестве атрибутов)
27. Программируйте на основе интерфейса а не его реализации.
28. Инкапсулируйте то, что меняется.
29. Практика.
30. Тестирование.
31. Документация.
32. Автоматическое построение.
33. Непрерывная интеграция.
34. BugZilla
