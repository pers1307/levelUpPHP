1. Ссылки на элементы массивов
2. Проверка типов входящих данных
3. Наследование, повторное использование кода (parent)
4. static создание себе подобного объекта
5. Использовать исключения, а не коды ошибок.
6. Последний catch с дефолтным Exeption не должен никогда вызываться! (В идеале)
7. Удобно передавать исключение вверх бросая throw в catch.
8. Все объекты передаются по ссылке.
9. Можно добавлять функционал в методы при помощи функций обратного вызова.
10. Классам подключенным через use можно давать алиасы (use pers1307\blog\Ret as bRet)
11. __autoload для подключения классов, которые будут использоваться в коде.
12. class_exists
13. Reflection API для анализа экземпляров класса. (стр 114)
14. Обязанность каждого класса должна быть единичной.
15. Для документации удобно использовать phpDocumentor (http://www.phpdoc.org/) composer require phpdocumentor/phpdocumentor
    установка через Composer. Прописать в командной строке
    (vendor\bin\phpdoc -d ./ForDoc/ -t ./docs)
16. Для загрузки PHPUnit composer require "phpunit/phpunit=4.8.*"
17. Для запуска тестирования использовать команду: php phpunit.phar CalculatorTest.php
18. Но лучше, поместить все тесты к отдельный каталог и запустить их разом используя
    команду: php phpunit.phar test/
19. Все комменческие приложения делятся на уровни:
    Ур. представления данных (уровень пользователя)
    Ур. команд и управления (обработка запроса пользователя)
    Ур. логики приложения (обработка бизнес запроса)
    Ур. данных (механизм хранения и получения информации)
20. Магический метод __sleep() вызывается, когда объект сериализуется.
21. Магический метод __wakeup() вызывается, когда объект десериализуется.
22. Паттерн Front - Controller, очень важно внедрить его! стр. 275
23. Для установки CodeSniffer composer require squizlabs/php_codesniffer
24. Для запуска CodeSniffer vendor\bin\phpcs Visitor.php и выдаст все необходимы для исправления ошибки.
25. https://github.com/squizlabs/PHP_CodeSniffer/wiki справка к Code Sniffer.
26.1 Включение - когда один класс является атрибутом другого класса.
26.2  Предпочитайте композицию наследованию. (Композиция это включение в класс других классов в качестве атрибутов)
27. Программируйте на основе интерфейса а не его реализации.
28. Инкапсулируйте то, что меняется.
29. Практика.
30. Тестирование.
31. Документация.
32. Автоматическое построение.
33. Непрерывная интеграция.
34. BugZilla
35. Суть паттерна ApplicationController в том, чтобы подтягивать все представления из файла,
упрощая тем самым конфигурирование
36. Суть паттерна FrontController в том, чтобы организовать единую точку входа в приложение,
подтягивать необходимые контроллеры (фаилы с логикой), через паттерн "команда",
хранить все настройки в отдельном файле, который будет кэшироваться, и организация архитектуры
через класс Request, который будет абстрагировать в себе HTTP запрос (его параметры).
37. Transaction Script представляет собой класс с sqlинами и класс, клторый просто их использует.
38. DomainObject - крутой паттерн имеющий у себя абстрактный класс и наследуемые от него классы,
которые очень похожи на entity, то есть в точности описывают таблицы из бд. Но,
при этом он может поддерживать композицию.
39. DataMapper (есть проблема : рассогласование нагрузки - не соответствие объектов и таблиц)
40. В паттерне DataMapper есть проблема, что когда мы дважды достаем из базы один и тот же объект,
то при изменении одного, другой не меняется. Так вот паттерн identity map решает эту проблему.
Создавая массив идентификаторов (сам при этом являясь singlaeton) классов объектов.
Иллюстрация https://github.com/gjerokrsteski/php-identity-map.
41. Unit of Work паттерн отслеживает объекты, которые были изменены, после извлечения из базы
помечая их особым образом, чтобы потом занести в базу только те объекты, которые были изменены.
42. Lazy Load паттерн сохраняет данные локально, чтобы постоянно не лазить в базу, и если
он из загружал, то просто отдает из локального хранилища.
43. Identity Object инкапсулирует в себе параметры, которые потом можно использовать для построения
запроса в БД. Этакий аккумулятор фильтров.
44. Selection и Update Factory инкапсуляция логики построения SQL запроса.
45. Domain Object Assembler - создание контроллера, который управляет процессом по
сохранению и извлечению данных.